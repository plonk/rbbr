= class Gdk::Window
A Gdk::Window is a rectangular region on the screen. It's a low-level object, used to implement high-level objects such as Gtk::Widget and Gtk::Window on the GTK+ level. A Gtk::Window is a toplevel window, the thing a user might think of as a "window" with a titlebar and so on; a Gtk::Window may contain many Gdk::Window. For example, each Gtk::Button has a Gdk::Window associated with it.

== Object Hierarchy
* Object
  * GLib::Instantiatable
    * GLib::Object
      * Gdk::Drawable
        * Gdk::Window

== Class Methods
--- Gdk::Window.new(parent, attributes, attributes_mask)
    Creates a new GdkWindow using the attributes from attributes. See Gdk::WindowAttr and ((<GdkWindowAttributesType|Gdk::Window#GdkWindowAttributesType>)) for more details. Note: to use this on displays other than the default display, parent must be specified.
    * parent: a Gdk::Window, or nil to create the window as a child of the default root window for the default display.
    * attributes: a Gdk::WindowAttr of the new window 
    * attributes_mask: mask indicating which fields in attributes are valid (((<GdkWindowAttributesType|Gdk::Window#GdkWindowAttributesType>)))
    * Returns: the new Gdk::Window 

--- Gdk::Window.at_pointer
    Obtains the window underneath the mouse pointer, returning the location of that window. 
    * Returns: [window, x, y]
       * window: Gdk::Window under the mouse pointer or nil if the window under the mouse pointer is not known to GDK (for example, belongs to another application)
       * x: origin of the window under the pointer 
       * y: origin of the window under the pointer 

--- constrain_size(geometry, flags, width, height)
    Constrains a desired width and height according to a set of geometry hints (such as minimum and maximum size).
    * geometry: a Gdk::Geometry
    * flags: a mask indicating what portions of geometry are set(((<GdkWindowHints|Gdk::Window#GdkWindowHints>))).
    * width: desired width of window 
    * height: desired height of the window 
    * Returns: [new_width, new_height]
       * new_width: resulting width 
       * new_height: resulting height 

--- Gdk::Window.process_all_updates
    Calls Gdk::Window#process_updates for all windows (Gdk::Window) in the application.

--- Gdk::Window.default_root_window
    Obtains the root window (parent all other windows are inside) for the default display and screen.
    * Returns: the default root window(Gdk::Window)

--- Gdk::Window.foreign_new(anid)
    Wraps a native window for the default display in a Gdk::Window. This may fail if the window has been destroyed. 
    For example in the X backend, a native window handle is an Xlib XID.
    * anid: a native window handle(Integer)
    * Returns: the newly-created Gdk::Window wrapper for the native window or nil if the window has been destroyed
--- Gdk::Window.foreign_new(display, anid)
    Wraps a native window for the default display in a Gdk::Window. This may fail if the window has been destroyed.
    For example in the X backend, a native window handle is an Xlib XID.  ((*Since 2.2*))
    * display: the Gdk::Display where the window handle comes from
    * anid: a native window handle(Integer)
    * Returns: the newly-created Gdk::Window wrapper for the native window or nil if the window has been destroyed

--- Gdk::Window.set_debug_updates(setting)
    With update debugging enabled, calls to Gdk::Window#invalidate clear the invalidated region of the screen to a noticeable color, and GDK pauses for a short time before sending exposes to windows during Gdk::Window#process_updates. The net effect is that you can see the invalid region for each window and watch redraws as they occur. This allows you to diagnose inefficiencies in your application. 
    In essence, because the GDK rendering model prevents all flicker, if you are redrawing the same region 400 times you may never notice, aside from noticing a speed problem. Enabling update debugging causes GTK to flicker slowly and noticeably, so you can see exactly what's being redrawn when, in what order.     
    The --gtk-debug=updates command line option passed to GTK+ programs enables this debug option at application startup time. That's usually more useful than calling Gdk::Window.set_debug_updates yourself, though you might want to use this function to enable updates sometime after application startup time.
    * setting: true to turn on update debugging  

--- Gdk::Window.toplevels
    Obtains an array of all toplevel windows known to GDK on the default screen. A toplevel window is a child of the root window.
    * Returns: an Array of toplevel windows

== Instance Methods
--- destroy
    Destroys window (destroys the server-side resource associated with window). Memory allocated for window may not be freed until all references to window are dropped. All children of window are also destroyed.
    There's normally no need to use this method, window are automatically destroyed when their reference count reaches 0.
    Note that a window will not be destroyed automatically when its reference count reaches zero(internal). You must call this method yourself before that happens.
    * Returns: nil

--- window_type
    Gets the type of the window. See ((<GdkWindowType|Gdk::Window#GdkWindowType>)).
    * Returns: self

--- show
    Like Gdk::Window#show_unraised, but also raises the window to the top of the window stack (moves the window to the front of the Z-order).
    This method maps a window so it's visible onscreen. Its opposite is Gdk::Window#hide.
    When implementing a Gtk::Widget, you should call this function on the widget's Gdk::Window as part of the "map" method.
    * Returns: self

--- show_unraised
    Shows a Gdk::Window onscreen, but does not modify its stacking order. In contrast, Gdk::Window#show will raise the window to the top of the window stack.
    On the X11 platform, in Xlib terms, this function calls XMapWindow() (it also updates some internal GDK state, which means that you can't really use XMapWindow() directly on a GDK window).

--- hide
    For toplevel windows, withdraws them, so they will no longer be known to the window manager; for all windows, unmaps them, so they won't be displayed. Normally done automatically as part of Gtk::Widget#hide.
    * Returns: nil

--- visible?
    Checks whether the window has been mapped (with Gdk::Window#show or Gdk::Window#show_unraised).
    * Returns: true if the window is mapped 

--- viewable?
    Check if the window and all ancestors of the window are mapped. (This is not necessarily "viewable" in the X sense, since we only check as far as we have GDK window parents, not to the root window.)
    * Returns: true if the window is viewable 

--- state
    Gets the bitwise OR of the currently active window state flags, from the (((<GdkWindowState|Gdk::Event#GdkWindowState>))) enumeration.
    * Returns: window state bitfield(((<GdkWindowState|Gdk::EventWindowState#GdkWindowState>)))

--- withdraw
    Withdraws a toplevel window (unmaps it and asks the window manager to forget about it). Normally done automatically by Gtk::Widget#hide called on a Gtk::Window.
    * Returns: nil

--- iconify
    Asks to iconify (minimize) window. The window manager may choose to ignore the request, but normally will honor it. Using Gtk::Window#iconify is preferred, if you have a Gtk::Window widget.
    * Returns: self

--- deiconify
    Attempt to deiconify (unminimize) window. On X11 the window manager may choose to ignore the request to deiconify. When using GTK+, use Gtk::Window#deiconify instead of the Gdk::Window variant. Or better yet, you probably want to use Gtk::Window#present, which raises the window, focuses it, unminimizes it, and puts it on the current desktop.
    * Returns: self

--- stick
    "Pins" a toplevel window such that it's on all workspaces and does not scroll with viewports, for window managers that have scrollable viewports. (When using Gtk::Window, Gtk::Window#stick may be more useful.)
    On the X11 platform, this function depends on window manager support, so may have no effect with many window managers. However, GDK will do the best it can to convince the window manager to stick the window. For window managers that don't support this operation, there's nothing you can do to force it to happen.
    * Returns: self

--- unstick
    Reverse operation for Gdk::Window#stick; See Gdk::Window#stick and Gtk::Window#unstick.
    * Returns: self

--- maximize
    Asks the window manager to maximize window, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "maximized"; so you can't rely on the maximization actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.
    If the window was already maximized, then this method does nothing.
    * Returns: self

--- unmaximize
    Asks the window manager to unmaximize window, if the window manager supports this operation. Not all window managers support this, and some deliberately ignore it or don't have a concept of "maximized"; so you can't rely on the unmaximization actually happening. But it will happen with most standard window managers, and GDK makes a best effort to get it to happen.
    If the window wasn't maximized, then this method does nothing.
    * Returns: self

--- move(x, y)
    Repositions a window relative to its parent window. For toplevel windows, window managers may ignore or modify the move; you should probably use Gtk::Window#move on a Gtk::Window widget anyway, instead of using GDK methods. For child windows, the move will reliably succeed.
    If you're also planning to resize the window, use Gtk::Window#move_resize to both move and resize simultaneously, for a nicer visual effect.
    * x: X coordinate relative to window's parent 
    * y: Y coordinate relative to window's parent 
    * Returns: self

--- resize
    Resizes window; for toplevel windows, asks the window manager to resize the window. The window manager may not allow the resize. When using GTK+, use Gtk::Window#resize instead of this low-level GDK function.
    Windows may not be resized below 1x1.
    If you're also planning to move the window, use Gdk::Window#move_resize to both move and resize simultaneously, for a nicer visual effect.
    * width: new width of the window 
    * height: new height of the window 
    * Returns: self

--- move_resize(x, y, width, height)
    Equivalent to calling Gdk::Windo#move and Gdk::Window#resize, except that both operations are performed at once, avoiding strange visual effects. (i.e. the user may be able to see the window first move, then resize, if you don't use Gdk::Window#move_resize.)
    * x: new X position relative to window's parent 
    * y: new Y position relative to window's parent 
    * width: new width 
    * height: new height 
    * Returns: self

--- scroll(dx, dy)
    Scroll the contents of window, both pixels and children, by the given amount. window itself does not move. Portions of the window that the scroll operation brings in from offscreen areas are invalidated. The invalidated region may be bigger than what would strictly be necessary. (For X11, a minimum area will be invalidated if the window has no subwindows, or if the edges of the window's parent do not extend beyond the edges of the window. In other cases, a multi-step process is used to scroll the window which may produce temporary visual artifacts and unnecessary invalidations.)
    * dx: Amount to scroll in the X direction 
    * dy: Amount to scroll in the Y direction 
    * Returns: self

--- reparent(new_parent, x, y)
    Reparents window into the given new_parent. The window being reparented will be unmapped as a side effect.
    * new_parent: new parent to move window into 
    * x: X location inside the new parent 
    * y: Y location inside the new parent 
    * Returns: self

--- clear
    Clears an entire window to the background color or background pixmap.
    * Returns: self

--- clear_area(x, y, width, height, gen_expose = false)
    Clears an area of window to the background color or background pixmap.
    * x: x coordinate of rectangle to clear 
    * y: y coordinate of rectangle to clear 
    * width: width of rectangle to clear 
    * height: height of rectangle to clear 
    * gen_expose: true if generates an expose event for the cleared area.
    * Returns: self

--- raise
    Raises window to the top of the Z-order (stacking order), so that other windows with the same parent window appear below window. If window is a toplevel, the window manager may choose to deny the request to move the window in the Z-order, Gdk::Window#raise only requests the restack, does not guarantee it.
    * Returns: self

--- lower
    Lowers window to the bottom of the Z-order (stacking order), so that other windows with the same parent window appear above window. If window is a toplevel, the window manager may choose to deny the request to move the window in the Z-order, Gdk::Window#lower only requests the restack, does not guarantee it.
    ((*Note*)) that Gdk::Window#show raises the window again, so don't call this method before Gdk::Window#show. (Try Gdk::Window#show_unraised.)
    * Returns: self

--- focus(timestamp)
    Sets keyboard focus to window. If window is not onscreen this will not work. In most cases, Gtk::Window#present should be used on a Gtk::Window, rather than calling this method.
    * timestamp: timestamp of the event triggering the window focus 
    * Returns: self

--- register_dnd
    Registers a window as a potential drop destination.
    * Returns: self

--- begin_resize_drag(edge, button, root_x, root_y, timestamp)
    Begins a window resize operation (for a toplevel window). You might use this method to implement a "window resize grip," for example; in fact Gtk::Statusbar uses it. The method works best with window managers that support the Extended Window Manager Hints spec (see ((<URL:http://www.freedesktop.org>))), but has a fallback implementation for other window managers.
    * edge: the edge or corner from which the drag is started (((<GdkWindowEdge|Gdk::Window#GdkWindowEdge>)))
    * button: the button being used to drag 
    * root_x: root window X coordinate of mouse click that began the drag 
    * root_y: root window Y coordinate of mouse click that began the drag 
    * timestamp: timestamp of mouse click that began the drag (use Gdk::Event#time) 
    * Returns: self

--- begin_move_drag(button, root_x, root_y, timestamp)
    Begins a window move operation (for a toplevel window). You might use this method to implement a "window move grip," for example. The method works best with window managers that support the Extended Window Manager Hints spec (see ((<URL:http://www.freedesktop.org>))), but has a fallback implementation for other window managers.
    * button: the button being used to drag 
    * root_x: root window X coordinate of mouse click that began the drag 
    * root_y: root window Y coordinate of mouse click that began the drag 
    * timestamp: timestamp of mouse click that began the drag 

--- begin_paint(area)
    Indicates that you are beginning the process of redrawing area. A backing store (offscreen buffer) large enough to contain region will be created. The backing store will be initialized with the background color or background pixmap for window. Then, all drawing operations performed on window will be diverted to the backing store. When you call Gdk::Window#end_paint, the backing store will be copied to window, making it visible onscreen. Only the part of window contained in region will be modified; that is, drawing operations are clipped to region.
    The net result of all this is to remove flicker, because the user sees the finished product appear all at once when you call Gdk::Window#end_paint. If you draw to window directly without calling Gdk::Window#begin_paint, the user may see flicker as individual drawing operations are performed in sequence. The clipping and background-initializing features of gdk_window_begin_paint are conveniences for the programmer, so you can avoid doing that work yourself.
    When using GTK+, the widget system automatically places calls to Gdk::Window#begin_paint and Gdk::Window#end_paint around emissions of the expose_event signal. That is, if you're writing an expose event handler, you can assume that the exposed area in Gdk::EventExpose has already been cleared to the window background, is already set as the clip region, and already has a backing store. Therefore in most cases, application code need not call Gdk::Window#begin_paint. (You can disable the automatic calls around expose events on a widget-by-widget basis by calling Gtk::Widget#double_buffered=.)
    If you call this method multiple times before calling the matching Gdk::Window#end_paint, the backing stores are pushed onto a stack. Gdk::Window#end_paint copies the topmost backing store onscreen, subtracts the topmost region from all other regions in the stack, and pops the stack. All drawing operations affect only the topmost backing store in the stack. One matching call to Gdk::Window#end_paint is required for each call to Gdk::Window#begin_paint.
    * area: a Gdk::Rectangle or Gdk::Region you intend to draw to 
    * Returns: self

--- end_paint
    Indicates that the backing store created by the most recent call to Gdk::Window#begin_paint should be copied onscreen and deleted, leaving the next-most-recent backing store or no backing store at all as the active paint region. See Gdk::Window#begin_paint for full details. It is an error to call this function without a matching Gdk::Window#begin_paint first.
    * Returns: self

--- invalidate(area, invalidate_children)
    Adds area to the update area for window. The update area is the region that needs to be redrawn, or "dirty region." The call Gdk::Window#process_updates sends one or more expose events to the window, which together cover the entire update area. An application would normally redraw the contents of window in response to those expose events.
    GDK will call Gdk::Window#process_all_updates on your behalf whenever your program returns to the main loop and becomes idle, so normally there's no need to do that manually, you just need to invalidate regions that you know should be redrawn.
    The invalidate_children parameter controls whether the region of each child window that intersects region will also be invalidated. If false, then the update area for child windows will remain unaffected. See Gdk::Window#invalidate_maybe_recurse if you need fine grained control over which children are invalidated.
    * area: a Gdk::Region or a Gdk::Recatangle
    * invalidate_children: true to also invalidate child windows  
    * Returns: self

--- invalidate_maybe_recurse(region){ ... }
    Adds region to the update area for window. The update area is the region that needs to be redrawn, or "dirty region." The call Gdk::Window#process_updates sends one or more expose events to the window, which together cover the entire update area. An application would normally redraw the contents of window in response to those expose events.
    GDK will call Gdk::Window.process_all_updates on your behalf whenever your program returns to the main loop and becomes idle, so normally there's no need to do that manually, you just need to invalidate regions that you know should be redrawn.
    The block controls whether the region of each child window that intersects region will also be invalidated. Only children for which block returns true will have the area invalidated. 
    * region: a Gdk::Region  
    * {|window| ... }: block to use to decide if to recurse to a child. If no block is given, it never recurses. Return true if the child have the area invalidated.
        * window: Gdk::Window
    * Returns: self

--- update_area
    Transfers ownership of the update area from window to the caller of the method. That is, after calling this method, window will no longer have an invalid/dirty region; the update area is removed from window and handed to you. If a window has no update area, Gdk::Window#update_area returns nil. 
    * Returns: the update area for window (Gdk::Region) or nil

--- freeze_updates 
    Temporarily freezes a window such that it won't receive expose events. The window will begin receiving expose events again when Gdk::Window#thaw_updates is called. If Gdk::Window#freeze_updates has been called more than once, Gdk::Window#thaw_updates must be called an equal number of times to begin processing exposes
    * Returns: self

--- thaw_updates
    Thaws a window frozen with Gdk::Window#freeze_updates.
    * Returns: self

--- process_updates(update_children)
    Sends one or more expose events to window. The areas in each expose event will cover the entire update area for the window (see Gdk::Window#invalidate for details). Normally GDK calls Gdk::Window.process_all_updates on your behalf, so there's no need to call this method unless you want to force expose events to be delivered immediately and synchronously (vs. the usual case, where GDK delivers them in an idle handler). Occasionally this is useful to produce nicer scrolling behavior, for example.
    * update_children: true if to also process updates for child windows.
    * Returns: self

--- internal_paint_info
    If you bypass the GDK layer and use windowing system primitives to draw directly onto a Gdk::Window, then you need to deal with two details: there may be an offset between GDK coordinates and windowing system coordinates, and GDK may have redirected drawing to a offscreen pixmap as the result of a Gdk::Window#begin_paint calls. This method allows retrieving the information you need to compensate for these effects. 
    This method exposes details of the GDK implementation, and is thus likely to change in future releases of GDK.
    * Returns: [real_drawable, x_offset, y_offset]
       * real_drawable: the Gdk::Drawable to which drawing should be done.  
       * x_offset: the X offset between coordinates in window, and the underlying window system primitive coordinates for real_drawable.
       * y_offset: the Y offset between coordinates in window, and the underlying window system primitive coordinates for real_drawable.  

--- user_data
    Retrieves the user data for window, which is normally the Gtk::Widget that window belongs to. See Gdk::Window#user_data=.
    * Returns: user data(Gtk::Widget)

--- user_data=(widget)
    For most purposes this method is deprecated. However, for historical reasons GTK+ stores the Gtk::Widget that owns a Gdk::Window as user data on the Gdk::Window. So, custom widget implementations should use this method for that. If GTK+ receives an event for a Gdk::Window, and the user data for the window is non-nil, GTK+ will assume the user data is a Gtk::Widget, and forward the event to that widget.
    * widget: user data(Gtk::Widget)
    * Returns: widget

--- set_user_data(widget)
    Same as user_data=.
    * widget: user data(Gtk::Widget)
    * Returns: self

--- override_redirect=(override_redirect)
    An override redirect window is not under the control of the window manager. This means it won't have a titlebar, won't be minimizable, etc. - it will be entirely under the control of the application. The window manager can't see the override redirect window at all. 
    Override redirect should only be used for short-lived temporary toplevel windows, such as popup menus. Gtk::Menu uses an override redirect window in its implementation, for example.
    * override_redirect: true if window should be override redirect  
    * Returns: override_redirect

--- set_override_redirect(override_redirect)
    Same as override_redirect=.
    * override_redirect: true if window should be override redirect  
    * Returns: self

--- shape_combine_mask(mask, x, y)
    Applies a shape mask to window. Pixels in window corresponding to set bits in the mask will be visible; pixels in window corresponding to unset bits in the mask will be transparent. This gives a non-rectangular window. 
    If mask is nil, the shape mask will be unset, and the x/y parameters are not used. 
    On the X11 platform, this uses an X server extension which is widely available on most common platforms, but not available on very old X servers, and occasionally the implementation will be buggy. On servers without the shape extension, this function will do nothing. 
    This method works on both toplevel and child windows.
    * mask: shape mask(Gdk::Pixmap, depth = 1) 
    * x: X position of shape mask with respect to window(Integer)
    * y: Y position of shape mask with respect to window(Integer)
    * Returns: self

--- shape_combine_region(shape_region, offset_x, offset_y)
    Makes pixels in window outside shape_region be transparent, so that the window may be nonrectangular. See also Gdk::Window#shape_combine_mask to use a bitmap as the mask. 
    If shape_region is nil, the shape will be unset, so the whole window will be opaque again. offset_x and offset_y are ignored if shape_region is nil. 
    On the X11 platform, this uses an X server extension which is widely available on most common platforms, but not available on very old X servers, and occasionally the implementation will be buggy. On servers without the shape extension, this method will do nothing. 
    This method works on both toplevel and child windows.
    * shape_region: region of window to be non-transparent  
    * offset_x: X position of shape_region in window coordinates  
    * offset_y: Y position of shape_region in window coordinates  
    * Returns: self

--- set_child_shapes
    Sets the shape mask of window to the union of shape masks for all children of window, ignoring the shape mask of window itself. Contrast with Gdk::Window#merge_child_shapes which includes the shape mask of window in the masks to be merged.
    * Returns: self

--- merge_child_shapes
    Merges the shape masks for any child windows into the shape mask for window. i.e. the union of all masks for window and its children will become the new mask for window. See Gdk::Window#shape_combine_mask. 
    This method is distinct from Gdk::Window#set_child_shapes because it includes window's shape mask in the set of shapes to be merged.
    * Returns: self

--- static_gravities=(use_static)
    Set the bit gravity of the given window to static, and flag it so all children get static subwindow gravity. This is used if you are implementing scary features that involve deep knowledge of the windowing system. Don't worry about it unless you have to.
    * use_static: true to turn on static gravity. If the server doesn't support static gravity, this raises a RuntimeError.
    * Returns: use_static

--- set_static_gravities(use_static)
    Same as static_gravities=.
    * use_static: true to turn on static gravity. If the server doesn't support static gravity, this raises a RuntimeError.
    * Returns: self

--- title=(title)
    Sets the title of a toplevel window, to be displayed in the titlebar. If you haven't explicitly set the icon name for the window (using Gdk::Window#icon_name=), the icon name will be set to title as well. title must be in UTF-8 encoding (as with all user-readable strings in GDK/GTK+). title may not be nil.
    * title: title of window
    * Returns: title
--- set_title(title)
    Same as title=.
    * Returns: title

--- background=(color)
    Sets the background color of window. (However, when using GTK+, set the background of a widget with Gtk::Widget#modify_bg - if you're an application - or Gtk::Style#set_background - if you're implementing a custom widget.) 
    The color must be allocated; Gdk::RGB.find_color is the best way to allocate a color. 
    See also Gdk::Window#set_back_pixmap.
    * color: an allocated Gdk::Color
    * Returns: self
--- set_background(color)
    Same as background=.
    * color: an allocated Gdk::Color
    * Returns: self

--- set_back_pixmap(pixmap, parent_relative)
    Sets the background pixmap of window. May also be used to set a background of "None" on window, by setting a background pixmap of nil. A background pixmap will be tiled, positioning the first tile at the origin of window, or if parent_relative is true, the tiling will be done based on the origin of the parent window (useful to align tiles in a parent with tiles in a child). 
    A background pixmap of nil means that the window will have no background. A window with no background will never have its background filled by the windowing system, instead the window will contain whatever pixels were already in the corresponding area of the display. 
    The windowing system will normally fill a window with its background when the window is obscured then exposed, and when you call Gdk::Window#clear.
    * pixmap: a Gdk::Pixmap, or nil
    * parent_relative: whether the tiling origin is at the origin of window's parent  
    * Returns: self

--- cursor=(cursor)
    Sets the mouse pointer for a Gdk::Window. Use Gdk::Cursor.new to create the cursor. To make the cursor invisible, use Gdk::Cursor.new(bitmap, mask, fg, bg. x, y) to create a cursor with no pixels in it. Passing nil for the cursor argument to Gdk::Window#cursor= means that window will use the cursor of its parent window. Most windows should use this default.
    * cursor: a Gdk::Cursor
    * Returns: cursor
--- set_cursor(cursor)
    Same as cursor=.
    * cursor: a Gdk::Cursor
    * Returns: self

--- geometry
    The X and Y coordinates returned are relative to the parent window of window, which for toplevels usually means relative to the window decorations (titlebar, etc.) rather than relative to the root window (screen-size background window). 
    On the X11 platform, the geometry is obtained from the X server, so reflects the latest position of window; this may be out-of-sync with the position of window delivered in the most-recently-processed Gdk::EventConfigure. Gdk::Window#position in contrast gets the position from the most recent configure event.
    * Returns: [x, y, width, height, depth]
       * x: X coordinate of window (relative to its parent)  
       * y: Y coordinate of window (relative to its parent)  
       * width: width of window  
       * height: height of window  
       * depth: bit depth of window

--- set_geometry_hints(geometry, geom_mask)
    Sets the geometry hints for window. Hints flagged in geom_mask are set, hints not flagged in geom_mask are unset. To unset all hints, use a geom_mask of 0 and a geometry of nil. 
    This method provides hints to the windowing system about acceptable sizes for a toplevel window. The purpose of this is to constrain user resizing, but the windowing system will typically (but is not required to) also constrain the current size of the window to the provided values and constrain programatic resizing via Gdk::Window#resize or Gdk::Window#move_resize. 
    Note that on X11, this effect has no effect on windows of type Gdk::Window::TEMP or windows where override_redirect has been turned on via Gdk::Window#override_redirect= since these windows are not resizable by the user. 
    Since you can't count on the windowing system doing the constraints for programmatic resizes, you should generally call Gdk::Window#constrain_size yourself to determine appropriate sizes.
    * geometry: a Gdk::Geometry
    * geom_mask: bitmask of ((<GdkWindowHints|Gdk::Window#GdkWindowHints>)) indicating fields of geometry to pay attention to
    * Returns: self

--- icon_list=(icons)
    Sets a list of icons for the window. One of these will be used to represent the window when it has been iconified. The icon is usually shown in an icon box or some sort of task bar. Which icon size is shown depends on the window manager. The window manager can scale the icon but setting several size icons can give better image quality since the window manager may only need to scale the icon by a small amount or not at all.
    * icons: An array of icons(Gdk::Pixbuf), of different sizes. 
    * Returns: icons

--- set_icon_list(icons)
    Same as icon_list=.
    * icons: An array of icons(Gdk::Pixbuf), of different sizes. 
    * Returns: self

--- modal_hint=(modal)
    The application can use this hint to tell the window manager that a certain window has modal behaviour. The window manager can use this information to handle modal windows in a special way. 
    You should only use this on windows for which you have previously called Gdk::Window#transient_for=.    * modal: true if the window is modal, false otherwise.  
    * Returns: modal

--- set_modal_hint(modal)
    Same as modal_hint=.
    * modal: true if the window is modal, false otherwise.  
    * Returns: self

--- type_hint=(hint)
    The application can use this call to provide a hint to the window manager about the functionality of a window. The window manager can use this information when determining the decoration and behaviour of the window. 
    The hint must be set before the window is mapped and the window should be a toplevel Gdk::Window.
    * hint: A ((<GdkWindowTypeHint|Gdk::Window#GdkWindowTypeHint>)) of the function this window will have
    * Returns: hint
--- set_type_hint(hint)
    Same as type_hint=.
    * hint: A ((<GdkWindowTypeHint|Gdk::Window#GdkWindowTypeHint>)) of the function this window will have
    * Returns: self

--- skip_taskbar_hint=(skips_taskbar)
    Toggles whether the toplevel window should appear in a task list or window list. If a window's semantic type as specified with Gdk::Window#type_hint= already fully describes the window, this function should NOT be called in addition, instead you should allow the window to be treated according to standard policy for its semantic type.  ((*Since 2.2*))
    * skips_taskbar: true to skip the taskbar
    * Returns: skips_taskbar

--- set_skip_taskbar_hint(skips_taskbar)
    Same as skip_taskbar_hints=. ((*Since 2.2*))
    * skips_taskbar: true to skip the taskbar
    * Returns: self

--- skip_pager_hint=(skips_pager)
    Toggles whether the toplevel window should appear in a pager (workspace switcher, or other desktop utility program that displays a small thumbnail representation of the windows on the desktop). If a window's semantic type as specified with Gdk::Window#type_hint= already fully describes the window, this method should NOT be called in addition, instead you should allow the window to be treated according to standard policy for its semantic type. ((*Since 2.2*))
    * skips_pager: true to skip the pager  
    * Returns: skips_pager

--- set_skip_pager_hint(skips_pager)
    Same as skip_pager_hint=. ((*Since 2.2*))
    * skips_pager: true to skip the pager  
    * Returns: self

--- position
    Obtains the position of the window as reported in the most-recently-processed Gdk::EventConfigure. Contrast with Gdk::Window#geometry which queries the X server for the current window position, regardless of which events have been received or processed. 
    The position coordinates are relative to the window's parent window.
    * Returns: [x, y]
       * x: X coordinate of window  
       * y: Y coordinate of window  

--- root_origin
    Obtains the top-left corner of the window manager frame in root window coordinates. The Gdk::Window should be a toplevel window.
    * Returns: [x, y]
       * x: X position of window frame  
       * y: Y position of window frame  

--- frame_extents
    Obtains the bounding box of the toplevel window, including window manager titlebar/borders if any. The frame position is given in root window coordinates. To get the position of the window itself (rather than the frame) in root window coordinates, use Gdk::Window#origin.
    * Returns: a Gdk::Rectangle to fill with bounding box of the window frame  

--- origin
    Obtains the position of a window in root window coordinates. (Compare with Gdk::Window#position and Gdk::Window#geometry which return the position of a window relative to its parent window.)
    * Returns: [x, y]
       * x: X coordinate  
       * y: Y coordinate  

--- pointer
    Obtains the current pointer position and modifier state. The position is given in coordinates relative to window.
    * Returns: [window, x, y, mask]
       * window: Gdk::Window under the mouse pointer or nil if the window containing the pointer isn't known to GDK
       * x: X coordinate of pointer  
       * y: Y coordinate of pointer  
       * mask: modifier mask (((<GdkModifierType|Gdk::Window#GdkModifierType>)))

--- parent
    Obtains the parent of window, as known to GDK. Does not query the X server; thus this returns the parent as passed to Gdk::Window.new, not the actual parent. This should never matter unless you're using Xlib calls mixed with GDK calls on the X11 platform. It may also matter for toplevel windows, because the window manager may choose to reparent them.
    * Returns: parent of window (Gdk::Window)

--- toplevel
    Gets the toplevel window that's an ancestor of window.
    * Returns: the toplevel Gdk::Window containing window

--- children
    Gets the list of children of window known to GDK. This method only returns children created via GDK, so for example it's useless when used with the root window; it only returns windows an application created itself. 
    Returns: an array of child windows inside window  

--- events
    Gets the event mask for window. See Gdk::Window#events=.
    * Returns: a ((<GdkEventMask|Gdk::Event#GdkEventMask>)) for window  
--- events=(event_mask)
    The event mask for a window determines which events will be reported for that window. For example, an event mask including Gdk::Event::BUTTON_PRESS_MASK means the window should report button press events. The event mask is the bitwise OR of values from the ((<GdkEventMask|Gdk::Event#GdkEventMask>)) enumeration.
    * event_mask: ((<GdkEventMask|Gdk::Event#GdkEventMask>)) for window  
    * Returns: event_mask

--- set_events(event_mask)
    Same as events=.
    * event_mask: ((<GdkEventMask|Gdk::Event#GdkEventMask>)) for window  
    * Returns: self

--- set_icon(icon_window, pixmap, mask)
    Sets the icon of a toplevel Gdk::Window as a pixmap or window. If using GTK+, investigate Gtk::Window#default_icon_list= first, and then Gtk::Window#icon_list= and Gtk::Window#icon=. If those don't meet your needs, look at Gdk::Window#icon_list=. Only if all those are too high-level do you want to fall back to Gdk::Window#set_icon.
    * icon_window: a Gdk::Window to use for the icon, or nil to unset  
    * pixmap: a Gdk::Pixmap to use as the icon, or nil to unset  
    * mask: a 1-bit pixmap (Gdk::Pixmap) to use as mask for pixmap, or nil to have none  
    * Returns: self

--- icon_name=(name)
    Toplevel windows may have a name used while minimized, distinct from the name they display in their titlebar. Most of the time this is a bad idea from a user interface standpoint. But you can set such a name with this method, if you like.
    * name : name of window while iconified (minimized)  
    * Returns: name
--- set_icon_name(name)
    Same as icon_name=.
    * name : name of window while iconified (minimized)  
    * Returns: self

--- transient_for=(parent)
    Indicates to the window manager that a toplevel window is a transient dialog associated with the application window parent. This allows the window manager to do things like center window on parent and keep window above parent. 
    See Gtk::Window#transient_for= if you're using Gtk::Window or Gtk::Dialog.
    * parent: another toplevel Gdk::Window  
    * Returns: parent
--- set_transient_for(parent)
    Same as transient_for=.
    * parent: another toplevel Gdk::Window  
    * Returns: self

--- role=(role)
    When using GTK+, typically you should use Gtk::Window#role= instead of this low-level method. 
    The window manager and session manager use a toplevel window's role to distinguish it from other kinds of window in the same application. When an application is restarted after being saved in a previous session, all windows with the same title and role are treated as interchangeable. So if you have two windows with the same title that should be distinguished for session management purposes, you should set the role on those windows. It doesn't matter what string you use for the role, as long as you have a different role for each non-interchangeable kind of window.
    * role: a String indicating its role  
    * Returns: role
--- set_role(role)
    Same as role=.
    * role: a String indicating its role  
    * Returns: self

--- group=(leader)
    Sets the group leader window for the toplevel window. By default, GDK sets the group leader for all toplevel windows to a global window implicitly created by GDK. With this method you can override this default. 
    The group leader window allows the window manager to distinguish all windows that belong to a single application. It may for example allow users to minimize/unminimize all windows belonging to an application at once. You should only set a non-default group window if your application pretends to be multiple applications.
    * leader: group leader window, or nil to restore the default group leader window  
    * Returns: leader
--- set_group(leader)
    Same as group=.
    * leader: group leader window, or nil to restore the default group leader window  
    * Returns: self

--- decorations
    Returns the decorations set on the Gdk::Window with Gdk::Window#decorations=.
    * window: The toplevel Gdk::Window to get the decorations from  
    * decorations: The window decorations will be written here  
    * Returns: true if the window has decorations set, false otherwise.  
--- decorations=(decorations)
    "Decorations" are the features the window manager adds to a toplevel Gdk::Window. This method sets the traditional Motif window manager hints that tell the window manager which decorations you would like your window to have. Usually you should use Gtk::Window#decorated= on a Gtk::Window instead of using the GDK method directly. 
    The decorations argument is the logical OR of the fields in the ((<GdkWMDecoration|Gdk::Window#GdkWMDecoration>)) enumeration. If Gdk::Window::DECOR_ALL is included in the mask, the other bits indicate which decorations should be turned off. If Gdk::Window::DECOR_ALL is not included, then the other bits indicate which decorations should be turned on. 
    Most window managers honor a decorations hint of 0 to disable all decorations, but very few honor all possible combinations of bits.
    * decorations: decoration hint mask (((<GdkWMDecoration|Gdk::Window#GdkWMDecoration>)))
    * Returns: self
--- set_decorations(decoration)
    Same as decorations=.
    * decorations : decoration hint mask (((<GdkWMDecoration|Gdk::Window#GdkWMDecoration>)))
    * Returns: self

--- functions=(functions)
    This method isn't really good for much. It sets the traditional Motif window manager hint for which operations the window manager should allow on a toplevel window. However, few window managers do anything reliable or interesting with this hint. Many ignore it entirely. 
    The functions argument is the logical OR of values from the ((<GdkWMFunction|Gdk::Window#GdkWMFunction>)) enumeration. If the bitmask includes Gdk::Window::FUNC_ALL, then the other bits indicate which functions to disable; if it doesn't include Gdk::Window::FUNC_ALL, it indicates which functions to enable.
    * functions: bitmask of operations to allow on window(((<GdkWMFunction|Gdk::Window#GdkWMFunction>)))
    * Returns: functions
--- set_functions(functions)
    Same as functions=.
    * functions: bitmask of operations to allow on window(((<GdkWMFunction|Gdk::Window#GdkWMFunction>)))
    * Returns: self

--- gl_capable?
    ((*Ruby/GtkGlExt*)) Returns whether the window is OpenGL-capable.
    * Returns: true if the window is OpenGL-capable, false otherwise.

--- gl_drawable
    ((*Ruby/GtkGlExt*)) Returns the Gdk::GLDrawable held by the window. In fact, this is a macro that casts the result of Gdk::Window#gl_window to Gdk::GLDrawable.
    * Returns: the Gdk::GLDrawable.

--- gl_window
    ((*Ruby/GtkGlExt*)) Returns the Gdk::GLWindow held by the window.
    * Returns: the Gdk::GLWindow.

--- set_gl_capability(glconfig)
    ((*Ruby/GtkGlExt*)) Set the OpenGL-capability to the window. This function creates a new Gdk::GLWindow held by the window.
    * glconfig: a Gdk::GLConfig.
    * Returns: the Gdk::GLWindow used by the window if it is successful, nil otherwise.

--- unset_gl_capability
    ((*Ruby/GtkGlExt*)) Unset the OpenGL-capability of the window. This function destroys the Gdk::GLWindow held by the window.
    * Returns: self

== Constants
=== GdkWindowType
Describes the kind of window.
--- ROOT
    root window; this window has no parent, covers the entire screen, and is created by the window system
--- TOPLEVEL
    toplevel window (used to implement Gtk::Window)
--- CHILD
    child window (used to implement e.g. Gtk::Button)
--- DIALOG
    useless/deprecated compatibility type
--- TEMP
    override redirect temporary window (used to implement Gtk::Menu)
--- FOREIGN
    foreign window (see Gdk::Window.foreign_new) 

=== GdkWindowClass
Gdk::Window::INPUT_OUTPUT windows are the standard kind of window you might expect. Gdk::Window::INPUT_ONLY windows are invisible; they are used to trap events, but you can't draw on them.
--- INPUT_OUTPUT
    window for graphics and events
--- INPUT_ONLY
    window for events only 

=== GdkWindowHints
Used to indicate which fields of a Gdk::Geometry object should be paid attention to. Also, the presence/absence of Gdk::Window::HINT_POS, Gdk::Window::HINT_USER_POS, and Gdk::Window::HINT_USER_SIZE is significant, though they don't directly refer to Gdk::Geometry fields. GDK_HINT_USER_POS will be set automatically by Gtk::Window if you call Gtk::Window#move. Gdk::Window::HINT_USER_POS and Gdk::Window::HINT_USER_SIZE should be set if the user specified a size/position using a --geometry command-line argument; Gtk::Window#parse_geometry automatically sets these flags.

--- HINT_POS
    indicates that the program has positioned the window
--- HINT_MIN_SIZE
    min size fields are set
--- HINT_MAX_SIZE
    max size fields are set
--- HINT_BASE_SIZE
    base size fields are set
--- HINT_ASPECT
    aspect ratio fields are set
--- HINT_RESIZE_INC
    resize increment fields are set
--- HINT_WIN_GRAVITY
    window gravity field is set
--- HINT_USER_POS
    indicates that the window's position was explicitly set by the user
--- HINT_USER_SIZE
    indicates that the window's size was explicitly set by the user 

=== GdkGravity
Defines the reference point of a window and the meaning of coordinates passed to Gtk::Window#move. See Gtk::Window#move and the "implementation notes" section of the extended window manager hints specification for more details.

--- GRAVITY_NORTH_WEST
    the reference point is at the top left corner.
--- GRAVITY_NORTH
    the reference point is in the middle of the top edge.
--- GRAVITY_NORTH_EAST
    the reference point is at the top right corner.
--- GRAVITY_WEST
    the reference point is at the middle of the left edge.
--- GRAVITY_CENTER
    the reference point is at the center of the window.
--- GRAVITY_EAST
    the reference point is at the middle of the right edge.
--- GRAVITY_SOUTH_WEST
    the reference point is at the lower left corner.
--- GRAVITY_SOUTH
    the reference point is at the middle of the lower edge.
--- GRAVITY_SOUTH_EAST
    the reference point is at the lower right corner.
--- GRAVITY_STATIC
    the reference point is at the top left corner of the window itself, ignoring window manager decorations. 

=== GdkWindowEdge
Determines a window edge or corner. 
--- EDGE_NORTH_WEST
    the top left corner.
--- EDGE_NORTH
    the top edge.
--- EDGE_NORTH_EAST
    the top right corner.
--- EDGE_WEST
    the left edge.
--- EDGE_EAST
    the right edge.
--- EDGE_SOUTH_WEST
    the lower left corner.
--- EDGE_SOUTH
    the lower edge.
--- EDGE_SOUTH_EAST
    the lower right corner. 

=== GdkWindowTypeHint
--- TYPE_HINT_NORMAL
    Normal toplevel window. 
--- TYPE_HINT_DIALOG
    A dialog window. 
--- TYPE_HINT_MENU
    Window used to implement a menu. 
--- TYPE_HINT_TOOLBAR
    Window used to implement toolbars.
--- TYPE_HINT_SPLASHSCREEN
    Window used to implement a splash screen displayed as an application is starting up. ((* Since 2.2 *))
--- TYPE_HINT_UTILITY
    Window used to implement a small persistent utility window, such as a palette or toolbox. It is distinct from type TOOLBAR because it does not correspond to a toolbar torn off from the main application. It's distinct from type DIALOG because it isn't a transient dialog, the user will probably keep it open while they're working. Windows of this type may set the WM_TRANSIENT_FOR hint indicating the main application window. ((* Since 2.2 *))
--- TYPE_HINT_DOCK
    Window used to implement a dock or panel feature. Typically a Window Manager would keep such windows on top of all other windows.  ((* Since 2.2 *))
--- TYPE_HINT_DESKTOP
    Window used to implement a desktop feature. This can include a single window containing desktop icons with the same dimensions as the screen, allowing the desktop environment to have full control of the desktop, without the need for proxying root window clicks.  ((* Since 2.2 *))

=== GdkWindowAttributesType
Used to indicate which fields in the Gdk::WindowAttr object should be honored. For example, if you filled in the "cursor" and "x" fields of Gdk::WindowAttr, pass "Gdk::Window::WA_X | Gdk::Window::WA_CURSOR" to Gdk::Window.new. Fields in Gdk::WindowAttr not covered by a bit in this enum are required; for example, the width/height, wclass, and window_type fields are required, they have no corresponding flag in GdkWindowAttributesType.

--- WA_TITLE
    Honor the title field
--- WA_X
    Honor the X coordinate field
--- WA_Y
    Honor the Y coordinate field
--- WA_CURSOR
    Honor the cursor field
--- WA_COLORMAP
    Honor the colormap field
--- WA_VISUAL
    Honor the visual field
--- WA_WMCLASS
    Honor the wmclass_class and wmclass_name fields
--- WA_NOREDIR
    Honor the override_redirect field 

=== GdkFilterReturn
Specifies the result of applying a filter block(See Gdk::Window#add_filter) to a native event.
--- FILTER_CONTINUE
    event not handled, continue processing.
--- FILTER_TRANSLATE
    translated event stored.
--- FILTER_REMOVE
    event handled, terminate processing. 

=== GdkModifierType
A set of bit-flags to indicate the state of modifier keys and mouse buttons in various event types. Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose, Apple, CapsLock or ShiftLock. 

Like the X Window System, GDK supports 8 modifier keys and 5 mouse buttons.

--- SHIFT_MASK
    the Shift key.
--- LOCK_MASK
    a Lock key (depending on the modifier mapping of the X server this may either be CapsLock or ShiftLock).
--- CONTROL_MASK
    the Control key.
--- MOD1_MASK
    the fourth modifier key (it depends on the modifier mapping of the X server which key is interpreted as this modifier, but normally it is the Alt key).
--- MOD2_MASK
    the fifth modifier key (it depends on the modifier mapping of the X server which key is interpreted as this modifier).
--- MOD3_MASK
    the sixth modifier key (it depends on the modifier mapping of the X server which key is interpreted as this modifier).
--- MOD4_MASK
    the seventh modifier key (it depends on the modifier mapping of the X server which key is interpreted as this modifier).
--- MOD5_MASK
    the eighth modifier key (it depends on the modifier mapping of the X server which key is interpreted as this modifier).
--- BUTTON1_MASK
    the first mouse button.
--- BUTTON2_MASK
    the second mouse button.
--- BUTTON3_MASK
    the third mouse button.
--- BUTTON4_MASK
    the fourth mouse button.
--- BUTTON5_MASK
    the fifth mouse button.
--- RELEASE_MASK
    not used in GDK itself. GTK+ uses it to differentiate between (keyval, modifiers) pairs from key press and release events.
--- MODIFIER_MASK

=== GdkWMDecoration
These are hints originally defined by the Motif toolkit. The window manager can use them when determining how to decorate the window. The hint must be set before mapping the window.
--- DECOR_ALL
    all decorations should be applied.
--- DECOR_BORDER
    a frame should be drawn around the window.
--- DECOR_RESIZEH
    the frame should have resize handles.
--- DECOR_TITLE
    a titlebar should be placed above the window.
--- DECOR_MENU
    a button for opening a menu should be included.
--- DECOR_MINIMIZE
    a minimize button should be included.
--- DECOR_MAXIMIZE
    a maximize button should be included. 

=== GdkWMFunction
These are hints originally defined by the Motif toolkit. The window manager can use them when determining the functions to offer for the window. The hint must be set before mapping the window.
--- FUNC_ALL
    all functions should be offered.
--- FUNC_RESIZE
    the window should be resizable.
--- FUNC_MOVE
    the window should be movable.
--- FUNC_MINIMIZE
    the window should be minimizable.
--- FUNC_MAXIMIZE
    the window should be maximizable.
--- FUNC_CLOSE
    the window should be closable. 

=== Misc
--- PARENT_RELATIVE
    A special value for Gdk::Pixmap variables, indicating that the background pixmap for a window should be inherited from the parent window.



* ((<Scritch>)) - Add a part of Ruby/GtkGlExt 
* ((<Masao>)) - Add a part of Ruby/GDK 
